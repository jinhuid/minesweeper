<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <style>
      #app {
        --size: 24px;
      }
      .game-info {
        height: 40px;
        width: 100%;
        background-color: #989898;
        display: flex;
        justify-content: space-around;
        line-height: 40px;
      }
      .mine {
        --border-width: 3px;
        flex-shrink: 0;
        height: var(--size);
        width: var(--size);
        box-sizing: border-box;
        line-height: calc((var(--size) - var(--border-width) * 2));
        font-size: calc((var(--size) - var(--border-width) * 2));
        text-align: center;
        background-color: rgb(192, 192, 192);
        border-width: var(--border-width);
        border-style: solid;
        border-color: rgb(244, 244, 244) rgb(128, 128, 128) rgb(128, 128, 128) rgb(244, 244, 244);
        cursor: pointer;
        user-select: none;
      }
      .mine:hover {
        background-color: rgb(147, 147, 147);
      }
      .mine.clean {
        background-color: transparent;
      }
      .color1 {
        color: rgb(0, 0, 255);
      }
      .color2 {
        color: rgb(0, 128, 0);
      }
      .color3 {
        color: rgb(255, 0, 0);
      }
      .color4 {
        color: rgb(128, 0, 128);
      }
      .color5 {
        color: rgb(128, 0, 0);
      }
      .color6 {
        color: rgb(165, 42, 42);
      }
      .color7 {
        color: rgb(0, 255, 255);
      }
      .color8 {
        color: rgb(0, 0, 0);
      }
    </style>
  </head>
  <body>
    <!-- ç»„ä»¶ä»…ä»…æ˜¯ä¸ºäº† ä¸è®©app vDomå…¨é‡å¯¹æ¯” -->
    <div id="app">
      <div style="width: min-content">
        <game-info class="game-info">
          <span>å‰©ä½™æ——å¸œ:{{flag}}</span>
          <span>æ—¶é—´:{{time}}s</span>
        </game-info>
        <div style="display: flex" v-for="(rowArr,r) in minefield" :key="r">
          <mine-list>
            <b
              v-for="(mine,c) in rowArr"
              :class="{ mine: true, clean: mine.cleaned, [mine.color]: true }"
              :key="c"
              @mousedown.left="onClick(r,c)"
              @contextmenu.prevent="onRightClick(r,c)"
            >
              {{mine.content}}
            </b>
          </mine-list>
        </div>
      </div>
      éš¾åº¦ï¼š
      <select @change="setMode($event)">
        <option v-for="item in optionalMode" :value="item" :selected="mode===item">{{item}}</option>
      </select>
    </div>

    <script>
      const FLAG = "ðŸš©"
      const MINE = "ðŸ’£"
      const BLANK = ""
      const { random, trunc } = Math
      const gameModeConfig = (() => {
        class MineMap {
          time = 0
          firstClick = true
          constructor({ row, column, mineNum }) {
            this.row = row
            this.column = column
            this.mineNum = mineNum
            this.flag = mineNum
            MineMap.inOutside = (r, c) => {
              return r < 0 || r >= this.row || c < 0 || c >= this.column
            }
            MineMap.directions = [
              [-1, 0],
              [0, -1],
              [0, 1],
              [1, 0],
              [-1, -1],
              [1, 1],
              [1, -1],
              [-1, 1],
            ]
            this.minefield = (() => {
              const mineProto = {
                get isMine() {
                  return this.type === 1
                },
                get withContent() {
                  return this.content !== BLANK
                },
                // è®¡ç®—å…«ä¸ªæ ¼å­æœ‰å¤šå°‘åœ°é›·
                get aroundMinesNum() {
                  let sum = 0
                  for (const [dr, dc] of MineMap.directions) {
                    sum +=
                      MineMap.inOutside(this._r + dr, this._c + dc) ||
                      !minefield[this._r + dr][this._c + dc].isMine
                        ? 0
                        : 1
                  }
                  return sum
                },
                // æ˜¯å¦å¯ä»¥æ‰©æ•£æ ¼å­
                get canExpand() {
                  return this.aroundMinesNum === 0
                },
                // æ‰©æ•£æ ¼å­
                expand(r, c, minefield, row_index_list = new Set()) {
                  if (
                    MineMap.inOutside(r, c) ||
                    minefield[r][c].cleaned ||
                    minefield[r][c].content === FLAG
                  ) {
                    return row_index_list
                  }
                  const block = minefield[r][c]
                  let num = block.aroundMinesNum
                  if (num) {
                    block.cleaned = true
                    block.content = num
                    block.color = `color${num}`
                    row_index_list.add(r)
                    return row_index_list
                  } else {
                    block.cleaned = true
                    for (const [dr, dc] of MineMap.directions) {
                      this.expand(r + dr, c + dc, minefield, row_index_list)
                    }
                    row_index_list.add(r)
                    return row_index_list
                  }
                },
                sweepOut() {
                  if (this.aroundMinesNum === 0 && !minefield[this._r][this._c].isMine) return
                  let for_count = 0
                  while (1) {
                    for (const [dr, dc] of [...MineMap.directions, [0, 0]]) {
                      if (MineMap.inOutside(this._r + dr, this._c + dc)) continue
                      const block = minefield[this._r + dr][this._c + dc]
                      if (block.isMine) {
                        const _block = minefield[trunc(random() * row)][trunc(random() * column)]
                        const temp = block.type
                        block.type = _block.type
                        _block.type = temp
                      }
                    }
                    for_count++
                    if (this.aroundMinesNum === 0 && !minefield[this._r][this._c].isMine) return
                    if (for_count === 99) {
                      alert("ç‚¸å¼¹å¤ªå¤šäº† è¯·å‡å°‘ä¸€äº›")
                      return
                    }
                  }
                },
              }
              const minefield = Array.from({ length: row }, (_, r) => {
                return Array.from({ length: column }, (_, c) =>
                  Object.assign(Object.create(mineProto), {
                    _r: r,
                    _c: c,
                    type: r * column + c < mineNum ? 1 : 0,
                    content: BLANK,
                    cleaned: false,
                    color: "",
                  }),
                )
              })
              return minefield
            })()
          }
        }
        const Modes = {
          easy: { row: 9, column: 9, mineNum: 10 },
          middle: { row: 16, column: 16, mineNum: 40 },
          hard: { row: 16, column: 30, mineNum: 99 },
          extreme: { row: 24, column: 45, mineNum: 230 },
          nightmare: { row: 50, column: 50, mineNum: 580 },
          legend: { row: 100, column: 100, mineNum: 2200 },
        }
        return { Modes, gen: (mode) => new MineMap(Modes[mode]) }
      })()

      const { createApp, ref, reactive, onBeforeMount, watch, h, toRaw, toRefs, computed } = Vue

      const app = createApp({
        setup() {
          const mode = ref(localStorage.getItem("mode") || "easy")
          const setMode = (e) => localStorage.setItem("mode", (mode.value = e.target.value))
          const optionalMode = Object.keys(gameModeConfig.Modes)
          /**
           * @typedef {Object} modeConfig
           * @property {number} time - æ¸¸æˆæ—¶é—´
           * @property {number} row - è¡Œæ•°
           * @property {number} column - åˆ—æ•°
           * @property {number} mineNum - åœ°é›·æ•°é‡
           * @property {number} flag - æ——å¸œæ•°é‡
           * @property {Object[][]} minefield - åœ°é›·åœºåœ°å›¾
           */
          const modeConfig = reactive(gameModeConfig.gen(mode.value))
          const {
            row,
            column,
            mineNum,
            minefield: map,
            time,
            flag,
            firstClick,
          } = toRefs(modeConfig)
          // å¯ä»¥åƒreactiveä¸€æ ·ä½¿ç”¨
          const minefield = new Proxy(map, {
            get: (target, prop) => target.value[prop],
            set: (target, prop, value) => (target.value[prop] = value),
          })

          console.log(minefield)

          const onClick = (r, c) => {
            const block = minefield[r][c]
            if (block.withContent) return
            if (firstClick.value) {
              block.sweepOut()
              firstClick.value = false
            }
            if (block.isMine) {
              block.cleaned = true
              block.content = MINE
              fail()
              return
            }
            // å½“å—è¾¾åˆ°ä¸€ä¸‡ä»¥ä¸Š reactiveçš„getterå¯èƒ½ä¼šé€ æˆæ€§èƒ½é—®é¢˜ æ‰€ä»¥ä½¿ç”¨åŽŸæ•°ç»„ åŽç»­æ‰‹åŠ¨æ›´æ–°
            const rawMap = toRaw(minefield)
            if (block.canExpand) {
              const row_index_list = block.expand(r, c, rawMap)
              // æ‰‹åŠ¨è§¦å‘æ‰€æœ‰è¡Œå­ç»„ä»¶æ›´æ–°
              console.log(row_index_list)
              for (let ri of row_index_list) {
                let temp = minefield[ri][0].content
                minefield[ri][0].content = "_"
                minefield[ri][0].content = temp
              }
              return
            }
            const num = (block.content = block.aroundMinesNum)
            block.color = `color${num}`
            block.cleaned = true
          }
          const onRightClick = (r, c) => {
            const block = minefield[r][c]
            if (block.cleaned) return
            if (block.content === FLAG) {
              if (block.isMine) {
                mineNum.value++
              }
              block.content = BLANK
              flag.value++
              return
            }
            if (flag.value <= 0) return
            block.content = FLAG
            flag.value--
            if (block.isMine) {
              mineNum.value--
            }
          }
          // æ‰“ä¹±åœ°é›·
          const setupMine = () => {
            let r = row.value,
              c = column.value
            for (let i = 0; i < mineNum.value; i++) {
              const mineType = minefield[trunc(i / c)][i % c].type
              const rand_i = trunc(random() * c * r)
              const _r = trunc(rand_i / c),
                _c = rand_i % c
              const targetType = minefield[_r][_c].type

              minefield[trunc(i / c)][i % c].type = targetType
              minefield[_r][_c].type = mineType
            }
          }

          onBeforeMount(setupMine)

          // é‡é…ç½®
          const reConfigure = () => {
            Object.assign(modeConfig, gameModeConfig.gen(mode.value))
            setupMine()
          }
          // è®¡æ—¶
          let timer
          const timekeeping = () => {
            timer = setInterval(() => {
              time.value++
            }, 1000)
          }

          const waitingForRender = (fn) => {
            requestAnimationFrame(() =>
              requestAnimationFrame(() => {
                fn()
              }),
            )
          }
          const fail = () => {
            waitingForRender(() => {
              clearInterval(timer)
              alert("æ¸¸æˆç»“æŸ")
              reConfigure()
            })
          }

          // åˆ‡æ¢éš¾åº¦
          watch(mode, reConfigure)

          watch(firstClick, (value) => {
            if (value === false) {
              timekeeping()
            }
          })

          watch(mineNum, (value) => {
            if (value === 0) {
              waitingForRender(() => {
                clearInterval(timer)
                alert(`You Win! ç”¨æ—¶${time.value}s`)
                reConfigure()
              })
            }
          })

          return {
            optionalMode,
            mode,
            setMode,
            ...toRefs(modeConfig),
            onClick,
            onRightClick,
          }
        },
      })
        .component("mine-list", {
          setup(props, { slots }) {
            return () => slots.default()
          },
        })
        .component("game-info", {
          setup(props, { slots }) {
            return () => h("div", slots.default())
          },
        })
        .mount("#app")
    </script>
  </body>
</html>
